/*!
Some hypothetical DeFi contract that will do smart things with the transferred tokens
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, setup_alloc, PanicOnDefault, collections::{Vector}, AccountId, PromiseOrValue, serde_json};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{U64, U128};

// Boilerplate for Rust smart contracts.
setup_alloc!();

// For simplicity, 10 fungible tokens are the cost for creating
// an exquisite corpse from NFTs approved to be used. It must be from the "ndai" NEAR account, which is the only token accepted.
// This does not apply to NFTs transferred to this contract, which
// will be used to create corpses automatically.
const FT_COST: u128 = 10u128;
const FT_CONTRACT_ACCOUNT: &str = "ndai";

type TokenId = String;
type VectorIndex = U64;

/// The kind of exquisite corpse can be:
/// * AutoGenerated: created automatically the moment when all three
///   pieces (head, midsection, feet) are transferred to the contract.
/// * ManuallySelected: created when users have given approvals for
///   all three pieces and a corpse is selected manually by token id.
///   The `AccountId` will save the account of the purchaser.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ECKind {
    AutoGenerated,
    ManuallySelected(AccountId)
}

/// This combines exactly one head, midsection, and feet when available.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ExquisiteCorpse {
    head: ECSection,
    midsection: ECSection,
    feet: ECSection,
    kind: ECKind
}

/// This struct is used for each section (head, midsection, feet)
/// and contains information about the NFT and previous owner.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ECSection {
    token_contract: AccountId,
    token_id: TokenId,
    previous_owner: AccountId
}

/// Fields beginning with `transferred_` are for NFTs that have been
/// transferred to this contract. Transferred NFTs will participate
/// in automatic generation.
/// Fields beginning with `approved_` are used more for curation of
/// an exquisite corpse and will cost a payment of fungible tokens.
///
/// `finished_art` is a `Vector` of all finished exquisite corpses, both
/// automatically generated and manually created ones.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    transferred_head: Vector<ECSection>,
    transferred_midsection: Vector<ECSection>,
    transferred_feet: Vector<ECSection>,
    approved_head: Vector<ECSection>,
    approved_midsection: Vector<ECSection>,
    approved_feet: Vector<ECSection>,
    finished_art: Vector<ExquisiteCorpse>
}

pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

trait NonFungibleTokenReceiver {
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool>;
}

trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: U64,
        msg: String,
    );
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTTransferApproveMsg {
    section: String,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FTTransferMsgDetails {
    index: VectorIndex,
    token_contract: AccountId,
    token_id: TokenId,
    previous_owner: AccountId
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FTTransferMsg {
    head: FTTransferMsgDetails,
    mid: FTTransferMsgDetails,
    feet: FTTransferMsgDetails
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// This function is called when some fungible tokens have been transferred to this account.
    /// Expect `msg` structure to be JSON:
    /// {
    ///   "head": {
    ///      index,
    ///      token_contract,
    ///      token_id,
    ///      previous_owner
    ///    },
    ///   "mid": { (same as above) },
    ///   "feet": { (same as above) }
    /// }
    /// The `index` is from the `finished_art` field. The reason why we need to include all the
    /// other fields is to ensure a `swap_remove` hasn't just happened and that the end user
    /// is creating through purchasing the exquisite corpse they desire.
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128> {
        // Ensure tokens are coming from the solo whitelisted account.
        assert_eq!(env::predecessor_account_id().as_str(), FT_CONTRACT_ACCOUNT, "Sorry, payment must be {} tokens from {} account.", FT_COST, FT_CONTRACT_ACCOUNT);

        // Make sure there are enough entries in each section
        assert!(self.can_create_corpse_from_approvals(), "Sorry, need at least one entry for all sections. (head, midsection, feet)");

        let msg_obj: FTTransferMsg = serde_json::from_str(msg.as_str()).expect("Could not marshal msg into expected format. Should be JSON containing three keys: head, mid, and feet. Each should contain the index of the Vector, in U64 form, like \"19\".");
        // Determine the amount of tokens to return.
        // Also return all tokens if the amount is less than the cost.
        let return_token_amount = if amount.0 > FT_COST {
            amount.0.saturating_sub(FT_COST)
        } else if amount.0 < FT_COST {
            env::panic(format!("Did not attach enough fungible tokens. The cost is {}", FT_COST).as_bytes());
        } else {
            0
        };

        // Ensure the sections they are trying to use haven't changed due to swap_remove
        if let Some(section) = self.approved_head.get(msg_obj.head.index.0) {
            assert_eq!(section.token_id, msg_obj.head.token_id, "Token ID does not match for index of head, please check again and update transaction.");
            assert_eq!(section.previous_owner, msg_obj.head.previous_owner, "Previous owner does not match for index of head, please check again and update transaction.");
            assert_eq!(section.token_contract, msg_obj.head.token_contract, "Token contract does not match for index of head, please check again and update transaction.");
        } else {
            env::panic(b"Did not find index for head.");
        }

        if let Some(section) = self.approved_midsection.get(msg_obj.mid.index.0) {
            assert_eq!(section.token_id, msg_obj.mid.token_id, "Token ID does not match for index of midsection, please check again and update transaction.");
            assert_eq!(section.previous_owner, msg_obj.mid.previous_owner, "Previous owner does not match for index of midsection, please check again and update transaction.");
            assert_eq!(section.token_contract, msg_obj.mid.token_contract, "Token contract does not match for index of midsection, please check again and update transaction.");
        } else {
            env::panic(b"Did not find index for midsection.");
        }

        if let Some(section) = self.approved_feet.get(msg_obj.feet.index.0) {
            assert_eq!(section.token_id, msg_obj.feet.token_id, "Token ID does not match for index of feet, please check again and update transaction.");
            assert_eq!(section.previous_owner, msg_obj.feet.previous_owner, "Previous owner does not match for index of feet, please check again and update transaction.");
            assert_eq!(section.token_contract, msg_obj.feet.token_contract, "Token contract does not match for index of feet, please check again and update transaction.");
        } else {
            env::panic(b"Did not find index for feet.");
        }

        // We're safe to create a custom exquisite corpse
        let new_corpse = ExquisiteCorpse {
            head: self.approved_head.swap_remove(msg_obj.head.index.0),
            midsection: self.approved_midsection.swap_remove(msg_obj.mid.index.0),
            feet: self.approved_feet.swap_remove(msg_obj.feet.index.0),
            kind: ECKind::ManuallySelected(sender_id.clone())
        };
        self.finished_art.push(&new_corpse);
        log!("Created new corpse by user selection. Thanks, {}!", sender_id);

        PromiseOrValue::Value(U128::from(return_token_amount))
    }
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    // This happens when a user adds an approval for their NFT
    // on this account.
    #[allow(unused_variables)]
    fn nft_on_approve(&mut self, token_id: TokenId, owner_id: AccountId, approval_id: U64, msg: String) {
        // See if the user is approving a head, midsection, or feet piece.
        // Expect msg structure to be JSON:
        // {
        //   "section": "head"|"mid"|"feet"
        // }
        let msg_obj: NFTTransferApproveMsg = serde_json::from_str(msg.as_str()).expect("Could not marshal msg into expected format. Should be JSON containing one key: section, with either head, mid, feet.");
        let ec_section = ECSection {
            // This is always called by an NFT contract
            token_contract: env::predecessor_account_id(),
            token_id,
            previous_owner: owner_id
        };
        match msg_obj.section.as_str() {
            "head" => {
                env::log(b"Thanks for approving a head piece!");
                self.approved_head.push(&ec_section)
            },
            "mid" => {
                env::log(b"Thanks for approving a midsection!");
                self.approved_midsection.push(&ec_section)
            },
            "feet" => {
                env::log(b"Thanks for approving some feet!");
                self.approved_feet.push(&ec_section)
            },
            _ => {
                env::log(b"Received invalid 'section' during approval, please use 'head', 'mid', or 'feet'.");
            }
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenReceiver for Contract {
    // This happens when a user transfers their NFT (head, midsection, or feet)
    // to be combined with other randomly submitted sections.
    #[allow(unused_variables)]
    fn nft_on_transfer(&mut self, sender_id: AccountId, previous_owner_id: AccountId, token_id: TokenId, msg: String) -> PromiseOrValue<bool> {
        // See if the user is transferring a head, midsection, or feet piece.
        // Expect msg structure to be JSON:
        // {
        //   "section": "head"|"mid"|"feet"
        // }
        let msg_obj: NFTTransferApproveMsg = serde_json::from_str(msg.as_str()).expect("Could not marshal msg into expected format. Should be JSON containing one key: section, with either head, mid, feet.");
        let ec_section = ECSection {
            // This is always called by an NFT contract
            token_contract: env::predecessor_account_id(),
            token_id,
            previous_owner: previous_owner_id
        };
        match msg_obj.section.as_str() {
            "head" => {
                env::log(b"Thanks for submitting a head piece!");
                self.transferred_head.push(&ec_section)
            },
            "mid" => {
                env::log(b"Thanks for submitting a midsection!");
                self.transferred_midsection.push(&ec_section)
            },
            "feet" => {
                env::log(b"Thanks for submitting some feet!");
                self.transferred_feet.push(&ec_section)
            },
            _ => {
                env::log(b"Received invalid 'section' during transfer, please use 'head', 'mid', or 'feet'.");
                return PromiseOrValue::Value(true)
            }
        }
        self.auto_create_corpse_if_can();

        PromiseOrValue::Value(false)
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            transferred_head: Vector::new(b"th".to_vec()),
            transferred_midsection: Vector::new(b"tm".to_vec()),
            transferred_feet: Vector::new(b"tf".to_vec()),
            approved_head: Vector::new(b"ah".to_vec()),
            approved_midsection: Vector::new(b"am".to_vec()),
            approved_feet: Vector::new(b"af".to_vec()),
            finished_art: Vector::new(b"f".to_vec()),
        }
    }

    /// Returns the exquisite corpse object by index.
    pub fn show_corpse(&self, index: U64) -> ExquisiteCorpse {
        self.finished_art.get(index.into()).expect("Could not find completed corpse with that index.")
    }

    /// Returns all exquisite corpses.
    pub fn show_all_corpses(&self) -> Vec<ExquisiteCorpse> {
        self.finished_art.to_vec()
    }

    pub fn show_all_transferred_pieces(&self) -> (Vec<ECSection>, Vec<ECSection>, Vec<ECSection>) {
        env::log(b"Showing in order of head, midsection, feet");
        (self.transferred_head.to_vec(), self.transferred_midsection.to_vec(), self.transferred_feet.to_vec())
    }

    pub fn show_all_approved_pieces(&self) -> (Vec<ECSection>, Vec<ECSection>, Vec<ECSection>) {
        env::log(b"Showing in order of head, midsection, feet");
        (self.approved_head.to_vec(), self.approved_midsection.to_vec(), self.approved_feet.to_vec())
    }

    /// For sections approved to be used in an exquisite corpse, this
    /// returns if one can be created.
    pub fn can_create_corpse_from_approvals(&self) -> bool {
        !self.approved_head.is_empty() &&
        !self.approved_midsection.is_empty() &&
        !self.approved_feet.is_empty()
    }

    fn auto_create_corpse_if_can(&mut self) {
        // If there is at least one of each, create exquisite corpse
        if !self.transferred_head.is_empty() &&
            !self.transferred_midsection.is_empty() &&
            !self.transferred_feet.is_empty() {
            let new_corpse = ExquisiteCorpse {
                head: self.transferred_head.pop().unwrap(),
                midsection: self.transferred_midsection.pop().unwrap(),
                feet: self.transferred_feet.pop().unwrap(),
                kind: ECKind::AutoGenerated
            };
            self.finished_art.push(&new_corpse);
            env::log(b"Automatically generated new corpse!");
        } else {
            env::log(b"Not enough to make a corpse yet.");
        }
        log!("Number of heads {}", self.transferred_head.len());
        log!("Number of midsections {}", self.transferred_midsection.len());
        log!("Number of feet {}", self.transferred_feet.len());
    }
}
